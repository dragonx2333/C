### 一、内存对齐的原因

1. **平台原因**：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些特定地址处取某些特定的数据，否则就会抛出硬件异常。内存对齐可以确保数据在不同的处理器之间保持一致性，因为对齐的数据更容易被缓存系统正确地识别和同步。
2. **效率原因**：处理器访问未对齐的内存时，可能需要进行多次访问并剔除多余数据，这相较于对齐内存访问会耗费更多时间，降低数据访问效率。内存对齐允许处理器一次性加载和存储多个数据项，而不是逐个处理，从而提高了内存访问的效率。

### 二、结构体内存对齐的规则

1. 第一个成员在结构体变量偏移量为0的地址处，即第一个成员必须从头开始。
2. 从第二个成员开始，每个成员在其自身对齐数的整数倍地址处开始存储。对齐数通常是编译器默认对齐数和成员字节大小中的较小值。
3. 结构体变量所占用的总空间大小是成员中最大对齐数的整数倍。
4. 当结构体中包含嵌套结构体时，嵌套结构体对齐到其自身成员最大对齐数的整数倍，并且整个结构体的大小也为当下成员最大对齐数的整数倍。

### 三、内存对齐的示例

~~~c
#include <stdio.h>

typedef struct16
{
    char a;//0~1
    int b;//4~7
    double c;//8~16
} Struct1;

//使用#pragma pack修改默认对齐数为4
#pragma pack(4)
typedef struct 
{
    char a;//0~1
    short b;//2~3
    int c;4~7
} Struct2;
#pragma pack()//恢复默认对齐数原值

int main() 
{
    printf("%d\n", sizeof(Struct1)); //16 
    printf("%d\n", sizeof(Struct2)); //8
    return 0;
}
~~~

### 四、内存对齐的应用

使内存较小的成员尽量聚到一起，减小结构体所占内存的大小

~~~c
struct S1
{
    char c1;//0~1
    char c2;//1~2
    int a;//4~7
};

struct S2
{
    char c1;//0~1
    int a;//4~7
    char c2;//8~9
};
~~~

S1所占的空间就比S2小

### 五、介绍一下offsetof

~~~c
size_t offset = offsetof(type, member);
~~~

type：结构体类型。

member：需要计算偏移量的结构体成员的名称。

offsetof宏的返回值是一个`ize_t类型的值，表示指定成员在结构体中的字节偏移量。